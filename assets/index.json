[{"relativeUrl":"/what-is-msb","url":"http://127.0.0.1:4000/what-is-msb","title":"What is microServicebus.com?","content":"Ultimately, microServiceBus.com is designed fill the gap between the out-of-the box device management provided by vendors such as Microsoft, Amazon and IBM, and what is required by the enterprise. It aims to address common challenges in the industry of IoT, such as planning for change, steep learning curves and provisioning of new devices. microServiceBus.com is a platform based on agents, also known as Nodes, running on gateways and controlled from a portal known as microServiceBus.com. microServiceBus.com and all related products and services are owned by AXIANS IoT Operation and is part of VINCI-Energies On-boarding new devices is difficult at scale. Gateways needs to automatically get assigned a cloud identity, receive keys and certificates. -All in a highly secure manner.\nmicroServiceBus.com provide a scalable, cross cloud vendor solution based either on integration with SIM card management tools like Cisco Jasper or MAC address white-listening. For more information: No part of any system will stand the test of time. Software is constantly updated to align with security threats or new required features.\nUpdate and patching are easily handled through microServiceBus.com, either through replacing entire firmware or individual services. Updates can be done manually or through scheduled tasks, for single, all or groups of devices.\nEasy deployments to IoT devices make ways for Agile development! For more information: Source code and services are not only deployed to devices, but needs to be audited and versioned to ensure the end-to-end business process.\nWith complete insight and traceability, code can be fully managed and versioned within the microServiceBus.com portal. However, we also integrate with Git repositories such as GitHub and Azure DevOps. For more information: Identifying and resolving problems can be a difficult mission in any system, but spread over many thousands of remotely located units brings it to a whole other level!\nmicroServiceBus.com provides great insight to what is and has happened on the device. Through it’s tracking capabilities, developers and operation staff can gain understanding of what is happening, and even remotely debugging the code, and instantly deploy fixes. For more information: microServiceBus.com extends to a complete Application Lifecycle Management system through its integration with 3rd party vendors, and continues to expand through its extensive API.\nAs of today, microServiceBus.com integrate with ServiceNow for Issue, problem- and release management, allowing customers to align their existing service desk and Nightly Operation Center (NOC). Integration with Cisco Jasper makes way for a compete SIM card management, along with GitHub, Azure DevOps, Active Directory and more. For more information:"},{"relativeUrl":"/installing-microservicebus-node","url":"http://127.0.0.1:4000/installing-microservicebus-node","title":"Installing microServiceBus-node","content":"microServiceBus-node is the agent that needs to run on your device, and requires node.js and npm to be install prior to installing the agent. Node.js® is a platform built on Chrome’s JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. Node.js provides lost of useful scenarios outside the scope of microSeviceBus.com® and as such it can be used together with other applications and solutions deployed on Node.js. Along with Node.js comes npm, which is a package manager for Node.js along with other things. After installing Node.js, you can use npm to install the microServiceBus.node package, and from there, you’re pretty much set to get started. To complete this process, just follow these three steps: To install Node.js go to https://nodejs.org/download/ and download the installation media for your platform. Make sure you install the npm package manager as well. Download the latest stable version and install the msi using the default settings. This will install both Node.js and npm. If you are on a Ubuntu or Debian operating system you simply open a terminal and use the following command: \nsudo apt-get update \nsudo apt-get install nodejs While there, continue to install npm using the following command: To make npm work on a Raspberry Pi you might need to set the registry to HTTP using this following command: Raspberry Pi 2 Model B for more info: Installing node on raspberryPi Open a terminal or command window and create a directory of your choice. Then type the following: This command creates and installs the package in a folder called node_modules. Browse to the node_modules/microservicebus-node folder. \nBefore you start your node, you need a temporary verification code which you can generate from the Node page. With the microServiceBus-node installed we need create the node in the microServiceBus.com portal. There are a number of ways to create and automatically provision nodes.\nFor now, we’ll keep it simple and use the Nodes page. Navigate to the Nodes page and create a node using the CREATE NEW NODE button on the top. Give the node a name and description and hit CREATE. Back at the the Nodes, your new Node should be visible in the list. With the microServiceBus-node package installed and the Node created in the portal, it’s time to start the node. The first time you start the node, it has no knowledge of what organization it belongs to nor does it have any access keys to authenticate to microServiceBus.com or you IoT hub for that matter. There are many ways you can pre-configure the node before it’s started, but again we’ll keep it simple. On the Nodes page in the portal, click the GENERATE button. Copy the generated verification code and go back to your terminal or console. The verification code is unique and valid for 30 min, and can be used to configure a node.\nIn your terminal/console, type the following: This should start the Node, which should begin by downloading microServiceBus-core, which together with microServiceBus-node make up the agent that we generally refer to as “The Node”. The installation should complete after a couple of minutes, after which it will authenticate it self using the temporary verification token you generated before. In the final step before completion, the Node will install the necessary packages for communication with your IoT hub, after which you should see you *Node online in the portal. If you want to stop the Node, simply hit CTRL+C/CMD+C in the terminal/console. To start it up again, simply type: Step 1: Create A Unit File Open a sample unit file using the command as shown below: Step 2: Add in the following text : Step 3: Set permissions\nThe permission on the unit file needs to be set to 644 : Step 4: Configure systemd\nNow the unit file has been defined we can tell systemd to start it during the boot sequence: Working with Node.js services Installing on Ubuntu Core Back to Quick Reference page: Quick Reference Back to home page: Home"},{"relativeUrl":"/what-is-a-node","url":"http://127.0.0.1:4000/what-is-a-node","title":"What is a Node?","content":"With an understanding of what a Micro Service is, it’s time to look at the Node. The Node is the agent running on your gateway or device. It is connected, owned and managed by an Organization. The Node is responsible for starting and stopping Flows and Services. -Essentially, the Node is where everything get processed. Every Service has a property called “Node”, which tells you where the Service is going to be executed, which could be any or all Nodes, regardless of location or platform. For instance, in the sample below we have a Flow, which describes the interchanges of the message. In this sample we have three Services; an Inbound FILE Service, a JavaScript Service and a Outbound Azure Send Event Service.  These Services can all run on the same or on different Nodes. In the sample above, all Services are run on the same Node. When a file is save in a specific folder, the Inbound FILE Service will pick it up, create a Messages and pass it back to the Node orchestrator. The Node will attach the Flow definition to the Message and check to see if the next Service in line (the JavaScript Service in this case) is hosted on the same Node. If this is the case, as in our sample, the Service will just pass the Message to the next Service without ever leaving the Node. If Services are configured to be executed on different Nodes, the Node will send the Message to microServicebus.com, which in turn will re-direct the Message from the first Node to the Node hosting the next Service in line. To send a Message from one Node to the other as in the sample above, you’d need to enable the “Allow send” on properties window of the first Node. You access the Nodes properties through the Action button on each Node on the Nodes page, and there are many properties that might be important: Disconnect policies are very important, and dictates when a device is considered off-line and what action to take. Clicking the ENVIRONMENT button will present you with valuable information such as Networks, CPU, Memory and environment variables. Most IoT platforms respects the notion of State. Microsoft calls it Device Twin, whereas Amazon calls it Things Shadow. In both cases it is a JSON document that represents the State of the Node. Click the DEVICE STATE button to review and change the State. See the Reviewing the Audit log section. By clicking the RETRIEVE SYSLOG button a call is sent to the Node to compress and submit syslogs to the portal. These logs can be downloaded from the Logs tab. Nodes are running on the Node.js platform, and as such is supported on every platform node.js is working on, which luckily is most of them. For more information about Node.js, please visit nodejs.org"},{"relativeUrl":"/what-is-a-micro-Service","url":"http://127.0.0.1:4000/what-is-a-micro-Service","title":"What is a Micro Service?","content":"Intro on what a micro Service is Explain how these communicate, tie together with intro on microservices. Continue on to how flows work to realise logic Introduction to flows Documentation on writing scripts Microservices in depth"},{"relativeUrl":"/what-is-a-flow","url":"http://127.0.0.1:4000/what-is-a-flow","title":"What is a Flow?","content":"Flows are entities responsible for orchestrating the execution of Services. Each instance of a flow, sometimes referred to as a Itinerary, holds state of all Services, Variables and Messages. While Variables and Messages may change over the lifetime of the Flow, the structure remains immutable, meaning once started, -Services and their related connections will not change although updated in the portal. You create Flows by going to the Flow page using the menu or by using the short-key CTRL+R and type “flow”. Clicking the “Create new” button on the top of the page takes you to the a page where give your flow a name and description. Clicking the “Create” button takes you to the Flow details page, and will present you with the Flow designer:  The Flow designer is made up of two parts; the toolbox and the designer. The toolbox shows all the Services created in your organization and Services that belongs to the Root organization which is not directly accessible to you, other than you have access to all its Services. As you might remember from the What is a Service? section, there are different kind of Services. Only three kind of Services are visible in the toolbox. Inbound Services starts the Flow. These Services will always create the Message along with the context. Inbound Services are often triggered on an interval or event such as reading a Modbus register every minute. Outbound Services receives Messages from Inbound- or Internal Services and are used to control meters and devices or transmitting Messages to IoT Hubs for example. Internal Services are generally used to manipulate Messages or Variables, such as transforming, batching or compressing Messages. Each instance of a flow (itinerary) has ONE Message which might change over the course of the lifetime of the itinerary. Messages are often a JavaScript object but does not have to. Connecting two Services instructs the orchestrator to pass the execution from one Service to the other. The default routing condition is ‘true’, meaning the Message will always take this route. However, you can set the routing condition by double-clicking the connection and set the route variable. Eg. Setting this condition means only route Messages to the destination if the temperature is more than 30 degrees. Variables are available through the the whole execution of the itinerary and can be read or updated. However, you need to create them prior to using them. Click the “VARIABLES” button at the bottom to add variables."},{"relativeUrl":"/what-is-a-flow#variables","url":"http://127.0.0.1:4000/what-is-a-flow#variables","title":"What is a Flow?","content":"Flows are entities responsible for orchestrating the execution of Services. Each instance of a flow, sometimes referred to as a Itinerary, holds state of all Services, Variables and Messages. While Variables and Messages may change over the lifetime of the Flow, the structure remains immutable, meaning once started, -Services and their related connections will not change although updated in the portal. You create Flows by going to the Flow page using the menu or by using the short-key CTRL+R and type “flow”. Clicking the “Create new” button on the top of the page takes you to the a page where give your flow a name and description. Clicking the “Create” button takes you to the Flow details page, and will present you with the Flow designer:  The Flow designer is made up of two parts; the toolbox and the designer. The toolbox shows all the Services created in your organization and Services that belongs to the Root organization which is not directly accessible to you, other than you have access to all its Services. As you might remember from the What is a Service? section, there are different kind of Services. Only three kind of Services are visible in the toolbox. Inbound Services starts the Flow. These Services will always create the Message along with the context. Inbound Services are often triggered on an interval or event such as reading a Modbus register every minute. Outbound Services receives Messages from Inbound- or Internal Services and are used to control meters and devices or transmitting Messages to IoT Hubs for example. Internal Services are generally used to manipulate Messages or Variables, such as transforming, batching or compressing Messages. Each instance of a flow (itinerary) has ONE Message which might change over the course of the lifetime of the itinerary. Messages are often a JavaScript object but does not have to. Connecting two Services instructs the orchestrator to pass the execution from one Service to the other. The default routing condition is ‘true’, meaning the Message will always take this route. However, you can set the routing condition by double-clicking the connection and set the route variable. Eg. Setting this condition means only route Messages to the destination if the temperature is more than 30 degrees. Variables are available through the the whole execution of the itinerary and can be read or updated. However, you need to create them prior to using them. Click the “VARIABLES” button at the bottom to add variables."},{"relativeUrl":"/what-is-a-flow#message","url":"http://127.0.0.1:4000/what-is-a-flow#message","title":"What is a Flow?","content":"Flows are entities responsible for orchestrating the execution of Services. Each instance of a flow, sometimes referred to as a Itinerary, holds state of all Services, Variables and Messages. While Variables and Messages may change over the lifetime of the Flow, the structure remains immutable, meaning once started, -Services and their related connections will not change although updated in the portal. You create Flows by going to the Flow page using the menu or by using the short-key CTRL+R and type “flow”. Clicking the “Create new” button on the top of the page takes you to the a page where give your flow a name and description. Clicking the “Create” button takes you to the Flow details page, and will present you with the Flow designer:  The Flow designer is made up of two parts; the toolbox and the designer. The toolbox shows all the Services created in your organization and Services that belongs to the Root organization which is not directly accessible to you, other than you have access to all its Services. As you might remember from the What is a Service? section, there are different kind of Services. Only three kind of Services are visible in the toolbox. Inbound Services starts the Flow. These Services will always create the Message along with the context. Inbound Services are often triggered on an interval or event such as reading a Modbus register every minute. Outbound Services receives Messages from Inbound- or Internal Services and are used to control meters and devices or transmitting Messages to IoT Hubs for example. Internal Services are generally used to manipulate Messages or Variables, such as transforming, batching or compressing Messages. Each instance of a flow (itinerary) has ONE Message which might change over the course of the lifetime of the itinerary. Messages are often a JavaScript object but does not have to. Connecting two Services instructs the orchestrator to pass the execution from one Service to the other. The default routing condition is ‘true’, meaning the Message will always take this route. However, you can set the routing condition by double-clicking the connection and set the route variable. Eg. Setting this condition means only route Messages to the destination if the temperature is more than 30 degrees. Variables are available through the the whole execution of the itinerary and can be read or updated. However, you need to create them prior to using them. Click the “VARIABLES” button at the bottom to add variables."},{"relativeUrl":"/what-is-a-micro-service","url":"http://127.0.0.1:4000/what-is-a-micro-service","title":"What is a Micro Service?","content":"Intro on what a micro Service is Explain how these communicate, tie together with intro on microservices. Continue on to how flows work to realise logic Introduction to flows Documentation on writing scripts Microservices in depth"},{"relativeUrl":"/services-and-scripts-in-microservicebus-in-depth","url":"http://127.0.0.1:4000/services-and-scripts-in-microservicebus-in-depth","title":"Services &amp; Scripts in microServiceBus.com in depth","content":"This page is dedicated to those with a bit of prior knowledge regarding how flows and services in microServiceBus.com works. If you are not familiar with these concepts yet, please visit the Getting started first. When you as a developer is writing a service to use in a flow, you are extending the microservice object microServiceBus.com is exposing. This object has a number of functions and properties that could help you develop your code. First we will go through what is required in your own service, then what is available to you and lastly som best practices. Start() This function will be called when your node starts and your service has been downloaded. @parameters : none @returns : void @example Tip!\nHere it is great to add all your NPM packages. Stop() This function will be called when you disable or restart your node. @parameters : none @returns : void @example Tip!\nHere it is recommended to stop your timers or clear your processes. Process() This function will be called when you send messages from another service to this @parameters : message , context @returns : void @example Tip!\nHere is where you can integrate your services to share data with each other. Tip!\nThese are just some examples of properties you can access. Check the source code at GitHub to find more. Search for new MicroService ;) this.GetCurrentState() Returns the “device twin” or “shadow” of the device from the connected IoT Hub. @parameters : none @returns : Object @example this.AddNpmPackage(npmPackages, logOutput, callback) Downloads the packages in run time and calls the callback when download and installation is completed @parameters : npmPackages (string), logOutput (Boolean), callback (function) @returns : Void @example this.SubmitMessage(msg, format, headers) Sends the message to the next service in the flow in a specified format with or without headers @parameters : msg (object or binary), format (string), headers (needs to be formatted as following : [{Variable : “[key]”, Value : “[value]”}]) @returns : Void @example In the meantime check out our repo at GitHub if you want to explore the source yourself. Do not hesitate to send any question or open any issue on something that is unclear or not working as expected. Back to home page: Home"},{"relativeUrl":"/get-insight-using-tracking","url":"http://127.0.0.1:4000/get-insight-using-tracking","title":"Get insight using tracking","content":"Though the Console can give you valuable understanding of the execution of your Services, it might not provide insight to your overall process and messages. -This is where Tracking comes to rescue. When enabling Tracking for a Node, the message along with its context for every executed Service will be transmitted to the Tracking database of microServiceBus.com. The data will be automatically deleted after 30 days, but is the single exception to storing content- (payload) and context data (meta data) in microServiceBus.com. Apart from this exception, sensor and meter data sent to the IoT Hub never passes microServiceBus.com. That being said, it’s a valuable tool when identifying and resolving issues. By default, Tracking is disabled, and you should always remember to disable it when your are done as Tracking will add extensively to your data usage. To enable the Tracking, navigate to the Nodes page, and simply toggle the Tracking button of the Node you’d like to work with.  Navigate to the Management page using the menu, click the Tracking tab at the top. If your Node has executed any Services since you enabled Tracking you should see a list of events:  Each line represent one execution of your Flow. Select one of the instances by clicking the View Details button.  This takes you to a new window, showing a snapshot of the state after each Service executed. The first tab shows you where in the flow the snapshot was captured. The other tabs reveal any errors, what the payload (content) looks like but also variables and metadata (context)."},{"relativeUrl":"/using-the-console","url":"http://127.0.0.1:4000/using-the-console","title":"Using the Console","content":"microServiceBus.com comes with a Console feature which provides similar output as you’d have through a terminal. Enabling Console output is a very powerful and common way to debug your Service and Flow. It will provide you with insight of how your Services behave and any issues you might experience. By default, Console output is disabled, and you should always remember to disable it when your are done as Console output will add extensively to your data usage. To enable the Console output, navigate to the Nodes page, and simply toggle the Console button of the Node you’d like to work with.  Without doing anything else, you will only see default output from the Node. To write your output from your Service, leave the Console window open, and open up a new window and navigate to the Service script and open the editor. To write to the Console output, use the Debug function as: Debug statements will work as console.log() and will always be visible in the terminal, however they will only be visible in the Console output if enabled in the portal. Similarly, you can also use the ThrowError function to track errors: Part from sending the exception information to the Console, the ThrowError function also submit tracking information, which can optionally be sent to Issue tracking systems like ServiceNow. The context parameter is optional, and only relevant if it exists such as in the Process function. Use an error number lower than 90000, as error code above are reserved for microServiceBus.com. To view the output, simply navigate to the Console in the portal. Tip: If other developers are using the Console at the same time as you, the output can be exhausting. -Use the filtering option and set it to the name of your Node."},{"relativeUrl":"/integrate-external-ticketing-system","url":"http://127.0.0.1:4000/integrate-external-ticketing-system","title":"Integrate external ticketing system (ServiceNow)","content":"ServiceNow was a software-as-a-service provider, providing technical management support, such as incident- asset- and license management, to the IT operations of large corporations, including providing help desk functionality. The company’s core business revolves around management of “incident, problem, and change” IT operational events. microServiceBus.com integrates with ServiceNow to delegate incidents to service desks and NOC’s (nightly operation center). ServiceNow also extends microServiceBus.com by providing automation capabilities for handling things like restarting Nodes. But more importantly ServiceNow really takes off where microServiceBus.com ends by escalating incidents to designated resources along with solid ITIL processes further extended to problem and release management. For better audit visibility, we recommend using a designated API user With the integration set up, all Nodes are represented as Configuration Items (CI’s) meaning any incident or problem will always be linked to the CI. This also gives you a great history view where you might find patterns of problems related to specific Nodes. By default, any Off-line node will be reported in ServiceNow as an incident together with any Unhandled exception. Off-line nodes however, will not get escalated until the connectivity has been verified again which by default happens ten minutes after the incident was reported. This is to mitigate Nodes that are connected using 2G/3G/LTE where short disconnected periods are common. Although it’s important to handle Off-line nodes, organizations often need to handle their own errors and exceptions. For instance, imagine a sensor reporting low battery or a heat pump reporting high pressure. These are not exceptions related to the platform, although it’s very important that such incidents gets escalated to ServiceNow. To handle custom issues, navigate to the Organization page, scroll down to the ServiceNow section and click the MANAGE INCIDENT POLICIES. As you can see in the list of Incident policies, you already have Unhandled Exceptions and Node is offline. If you’re calling this from a Process function, you may add the context variable as the first parameter."},{"relativeUrl":"/integrate-sim-card-management","url":"http://127.0.0.1:4000/integrate-sim-card-management","title":"Integrate SIM card management","content":"Cisco Jasper is a powerful SIM card management tool where you can manage state and set up automation rules for your SIM cards. The integration with Cisco Jasper enables automatically on-boarding of new devices wit no effort part from powering on the device. For this provisioning process to work, you need to set up a two-way trust between microServiceBus.com and Cisco Jasper; one for Cisco Jasper to notify microServiceBus.com of newly activated devices (SIM cards) and one for microServiceBus.com to call Cisco Jasper to make changes of updates to the configuration. microServiceBus.com will also query Cisco Jasper to notify users when data plans are reaching their limits. To set up the Cisco Jasper integration, follow these tow steps: Although microServiceBus.com can call Cisco Jasper on behalf of any user, it’s always a good practice to use a dedicated user. This way it becomes clearly visible in Cisco Jasper in which context any changes has been done. Your microServiceBus.com Organization is now set to call the Cisco Jasper API. With these steps completed, SIM cards that gets activated will automatically trigger your automation rule which will cause Cisco Jasper to call microServiceBus.com to create the Node in both  microServiceBus.com and your IoT Hub. Shortly after the Node gets online it should automatically receive credentials to log on to the IoT Hub."},{"relativeUrl":"/using-microservicebus-api","url":"http://127.0.0.1:4000/using-microservicebus-api","title":"Using microServiceBus API","content":"The microServiceBus API hosts many of the operations otherwise available through the UI, allowing other applications to interact with Nodes and Meters. In many cases, the API is used from the Business Operation allowing them to configure and interact with nodes, meters and sensors. Business Operation generally work more with configuration tasks, using tools provided elsewhere. microServiceBus.com API is a REST based API that can be called from any application. To use the API you need an API key which you can receive by navigating to the Account page (click your user account in the top right corner). On the Account page, click “API keys”. Enter your password and token expiration and hit the GET API KEY button. Copy the token, and navigate to the swagger page. Paste your token in the api_key field at the top of the field. Tip: To use the API from outside the swagger page, add the token to the Authorization header. Tip: It’s not recommended to use a normal user account as the API account. Instead create a user account for each service or application that will use the API. This way it’s easier to track and audit updates. The microServiceBus API is segmented into groups of entities:"},{"relativeUrl":"/working-with-external-source-code-providers","url":"http://127.0.0.1:4000/working-with-external-source-code-providers","title":"Working with external source code providers","content":""},{"relativeUrl":"/remote-debug-your-microservices","url":"http://127.0.0.1:4000/remote-debug-your-microservices","title":"Remote debug your microservices","content":""},{"relativeUrl":"/reviewing-the-auditlog","url":"http://127.0.0.1:4000/reviewing-the-auditlog","title":"Reviewing the Audit log","content":"Audit logs can be used to find out who did what and when. All changes made to entities below are subject for auditing: The Audit logs are available by navigating to the Management page, and selecting the Audit logs tab. Or from individual entities by clicking the AUDIT LOGS button."},{"relativeUrl":"/running-microservicebus-node-on-a-yocto-image","url":"http://127.0.0.1:4000/running-microservicebus-node-on-a-yocto-image","title":"Running microServiceBus-node on a yocto image","content":"Intro on what this page aims to answer. If the page is tutorial-like do numbering and at the end of the page link to related topics. If you dont know Markdown try this Cheatsheet Always checkout branch before editing so no conflict happens. When you are done with your edit, create a pull request. Specify code language in code examples. Tip! Tips should be written like this Always use cursive on reserved words like node, microservice, microServiceBus.com, flows, organization, tags etc. Images can be added in different ways. Depending on the use and size of the image you whant to use. Standard: ![altText](/images/Logosmall.png)  Imports the image at the original size Advanced: Use raw_html to resize and modify your image. You can use padding, width, hight etc.  Back to home page: Home This is a demo"},{"relativeUrl":"/site-verification","url":"http://127.0.0.1:4000/site-verification","title":"Site verification","content":"Arguably, one of the biggest challenges when rolling out new solutions, is the on-site installation and setup. Mounting a gateway and getting it connected to the cloud is often a minor part of the complete installation. Lots of wires, meters and other equipment might be required, and it’s vital that everything is connected before the on-site engineer leaves the premises and call it a day. The solution to this is to create a Site Verification test, and let the on-site engineer run the test(s) to verify it’s all up and running. Site verification test is nothing but a normal unit test. If you have ever written a unit test before, this should be really easy. If not, don’t panic. The Test-Driven Development pattern is very easy to understand. The Site Verification Test is using mocha which comes preinstalled for you Node. Writing a verification tests are just like writing a normal Service. In the microServiceBus.com portal navigate to Scripts &amp; Services using the navigation menu. Click the CREATE NEW button. Set a name, filename and description. Before you hit the CREATE button, select Test file in the Service type drop-down list. In many scenarios you need the site engineer to be able to provide input to the test, such as which serial port or IP address to use. As with normal Services, add your parameters in the Static Properties tab. Make sure to use well descriptive names as these properties are going to be presented in the Site Verification Application Inside your test script, you can access these properties using the following syntax: Every test case file follows the same basic pattern. First, you have a describe block: describe is used to group individual tests. The first parameter should indicate what we’re testing — in this case, we’re going to make sure we’re connected to a meter, as we’ve passed in the string ‘Meter connection’. Secondly, inside the describe, we’ll have it blocks: it is used to create the actual tests. The first parameter to it should provide a human-readable description of the test. For example, we can read the above as “should be a valid IP address”, which is a good description of what we expect. The code to implement the test is then written inside the function passed to it. All Mocha tests are built from these same building blocks, and they follow this same basic pattern. To validate the IP Address, we can use a Regular expression, and test it with the IP Address parameter provided by the site engineer: Your test can have any number if if blocks! Before you can run the test on the Node you need to set the Node in “Test mode”. Navigate to the Node page and select properties from the Action menu. On the Node properties page, set the Mode to “Test mode”. Also click the Identities tab on the top and copy the serial number (set it if empty). Last, save the changes. On the Save confirmation dialog, click the “VIEW QR CODE” button. User your phone to navigate to the site verification app. Follow the instructions on the screen to verify the installation."},{"relativeUrl":"/working-with-service-properties","url":"http://127.0.0.1:4000/working-with-service-properties","title":"Working with service properties","content":"The service property window is where you define the characteristics of your service. All properties are divided into three categories; General, Static and Security properties. While Static and Security properties are specific to each micro service, the General properties are generic and applies to all services. Most properties can be set using dynamic expressions. For instance, the sample below shows Static properties for the File outbound service. While the Path property is staticly set, the File name property is set to %guid%. This is called a Marco, and is unique to certain services. For the File outbound service, this means the name is going to get a unique name. Sometimes you might want to use some value from the payload to set a property. In such cases we use brackets. In the sample above we are transmitting an order with a property called orderid. You can combine two or more properties such as [firstName]_[lastName].json. You can also use context variables, in which case use curly brackets as above."},{"relativeUrl":"/what-is-an-organization","url":"http://127.0.0.1:4000/what-is-an-organization","title":"What is an Organization?","content":"Organizations separates ownership of artefacts (see Flows, Services and Nodes). This is also where you manage users and integration with ServiceNow, Cisco Jasper, Azure DevOps, GitHub and more. There are two roles within your organization; Owners and Co-Admins. Only owners can do user administration and moving nodes between organizations. To add a user to your organization, go to the Organization page and click the “ADD CO-ADMIN” button. Provide the email address of the person you’d like to invite. The invited person will then get an email with instructions of how to register and join the organization. If the invited person already have an account, he or she can go the the Organization page of any organization to accept the invite. ADFS is a standards-based service that allows the secure sharing of identity information between trusted business partners (known as a federation) across domains. The ADFS integration allows for people in your organization to authenticate themselves using your organization’s ADFS. By setting up integration with ADFS you’re essentially telling microServiceBus.com to trust your domain. Should you prefer having users signing in with an Active Directory account, you can provide necessary settings on the Organization page. For more information:"},{"relativeUrl":"/microservicebus-release-management","url":"http://127.0.0.1:4000/microservicebus-release-management","title":"microServiceBus.com release management","content":"microServiceBus.com (portal) along with agent packages; microServiceBus-node and microServiceBus-core are normally release as: New releases of the public portal (https://microServiceBus.com) are initially released to the developing environment (DEV) dev.microServiceBus.com, which is publicly available with no connection to the production data. This environment is predominantly used for developing and integration testing. Once testing is complete, changes are replicated to the STAGE environment (stage.microServiceBus.com). This environment is connected to the same data source as the production environment and should be used for acceptance testing. When code is submitted to the STAGE branch, ALL stage environments are affected including private and self-hosted, environments. Once acceptance testing is complete, PROD and STAGE environment are “swapped”, meaning IP addresses of https://microServiceBus.com and https://stage.microServiceBus.com are swapped leaving the STAGE environment in “last working state” and can be used as backup should issues be found in a later state. The process of swapping PROD and STAGE for private and self-hosted environments are done upon acceptance of the customer. It is however recommended to update at least once a month. Depending on the underlying architecture of the hardware, updates of the mSB-node can be handled differently. If, for instance, the mSB-node package is running in a Ubuntu Snap or a Docker container the updates of these packages are handled either manually or automatically along with the selected infrastructure. Should a customer want to have control over the releases of mSB-node, they can choose to fork the microServiceBus-node github repo and/or publish their forked repo as a custom npm package. Following this pattern, customer can choose when they decide when to publish new releases. Worth pointing out, that although this options gives the most control, it also requires a great deal of insight. Organizations can also control the version of microServiceBus-core using the settings on the Organization. The Node Version setting can be set to either latest, beta, ignore or a specific version. Normally, organizations would choose latest or a specific version for their production environment, however if you’d like to test the beta version on one or a subset of nodes, you can tag the node with BETA on the property page of the node. Once your Flow are in production we recommend locking the version of each Service by opening the property window of each Service and check the “Lock to version” checkbox. This will make sure the specific version of the Service is used, regardless of if it has been updated. Sometimes we need to test an update of a Service in production, while making sure other Nodes are still using the last stable version. This is common in scenarios where a Flow is used by many Nodes using tags. In such cases, a specific tag is applied to one or more nodes, such as “Amsterdam”, and rather than configuring a Service run on a specific Node, you’d use the tag instead (#Amsterdam). However, using tags this way will force all Nodes using the same version of the Service. -If you want to run one of the nodes on the latest version, you can apply the “BETA” tag to the node, in which case it will always ignore the “Lock to version” setting"},{"relativeUrl":"/get-remote-access-to-your-nodes","url":"http://127.0.0.1:4000/get-remote-access-to-your-nodes","title":"Get remote access to your Nodes","content":""},{"relativeUrl":"/groups-and-tags","url":"http://127.0.0.1:4000/groups-and-tags","title":"Grouping and tagging Nodes","content":""},{"relativeUrl":"/provitioning-of-nodes","url":"http://127.0.0.1:4000/provitioning-of-nodes","title":"On-boarding and provisioning of new devices","content":""},{"relativeUrl":"/steering","url":"http://127.0.0.1:4000/steering","title":"Controlling Nodes","content":""},{"relativeUrl":"/user-management","url":"http://127.0.0.1:4000/user-management","title":"User management","content":"Sharing is caring, and that goes for your organizations as well. Time to go through different user scenarios for your organizations. There are two roles within your organization; Owners and Co-Admins. Only owners can do user administration and moving nodes between organizations. To add a user to your organization, go to the Organization page and click the “ADD CO-ADMIN” button. Provide the email address of the person you’d like to invite. The invited person will then get an email with instructions of how to register and join the organization.  If the invited person already have an account, he or she can go the  Organization page of any organization to accept the invite. Note in the picture above that once you have added a Co-Admin to your organization you now have the option to assign the Owner role to that user. You need to be owner of an organization to assign the owner role. Once you have assign the owner role to a user it can’t be reverted by you, only the user in question can remove the role assigned to them. ADFS is a standards-based service that allows the secure sharing of identity information between trusted business partners (known as a federation) across domains. The ADFS integration allows people in your organization to authenticate themselves using your organization’s ADFS. By setting up integration with ADFS you’re essentially telling microServiceBus.com to trust your domain. Should you prefer having users signing in with an Active Directory account, you can provide necessary settings on the Organization page. Once you have clicked the Edit button on the Organization page you will have to edit these fields:  Once the correct information is applied, you should now be able to login with your Active Directory account. Don’t forget to invite your Active Directory account before you try to login with it."},{"relativeUrl":"/gettingStarted-list","url":"http://127.0.0.1:4000/gettingStarted-list","title":null,"content":""},{"relativeUrl":"/quickreference-list","url":"http://127.0.0.1:4000/quickreference-list","title":null,"content":""},{"relativeUrl":"/news","url":"http://127.0.0.1:4000/news","title":"News","content":"Enable / Disable node with CTRL+R creates multiple services on node #535  Prevent Unauthenticated SignalR calls from nodes\nAll calls from Nodes are authenticated directly on connection rather than only using SignIn method. Mobile console\nThe *Console has been extended to the mobile view History log of all successful and failed transmitted messages along with related events.\nFrom the Node page users can now access last weeks event Action drop-down menu. This will provide good insight of everything happening on the node. Highlighting in Console\nAlong with filtering users are now able to highlight events of interest. GitHub integration\nYou can now synchronize Scripts in your microServiceBus.com organization with your gitHub Repo! Just follow this simple guide to Integreate with GitHub. Aggregations of this information can be accessed from the portal. Azure device sdk (azure-iot-device-*) has been updated to 1.4.0.\n1.4.0 comes with many updates and improvements for handling re-connect and persistence of messages. Allow ‘node restore’ with parameter specifying customer’s (private) environment uri.\nWhen starting up the node for the first time you can now use -env to specify private or self hosted hubs: Always persist messages on Node \nBy setting the retention period on the Node greater than \n“0”, all outgoing event and messages are persisted on the device until the retention period is exceeded or the available storage is less than 25%. Fixes: Implement retry policy “NoRetry” for Azure IoT. Migrated to 1.3.0 of for Azure device SDK."},{"relativeUrl":"/administrativetasks-list","url":"http://127.0.0.1:4000/administrativetasks-list","title":null,"content":""},{"relativeUrl":"/integration-list","url":"http://127.0.0.1:4000/integration-list","title":null,"content":""}]
